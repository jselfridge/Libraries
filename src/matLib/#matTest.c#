
//============================================================
//  matTest.c
//  Justin M Selfridge
//============================================================
#include "matLib.h"


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  mat_LU
//  SOlves for the LU decomposition of a matrix (if it exists).
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void mat_LU ( matrix* mat, matrix** L, matrix** U )  {

  mat_err( *L != NULL || *U != NULL, "Error (mat_LU): Matricies L and U must be null." );

  int i, j, n, m, p, q, r, c;
  float pivot, scale, val;
  matrix* row;

  r = mat->rows;
  c = mat->cols;
  row = mat_init(1,c);

  *U = mat_copy(mat);
  *L = mat_init(r,r);

  printf("Starting process: \n");
  mat_print(mat);

  // Pivot position
  n = 1;  m = 1;

  // L matrix position
  p = 1;  q = 1;

  // Loop through columns
  for ( j=1; j<=c; j++ ) {
    printf("Col: %d \n", j );

    // Obtain current pivot
    pivot = mat_get(*U,n,m);
    printf("pivot: [%d,%d] %3.3f \n", n, m, pivot );

    /*
    // Test for zero column entries
    if(!pivot) {
      for ( j=n+1; j<=r; j++ ) {
	val = mat_get(*U,j,i);
        mat_err( val!=0, "Error (mat_LU): The LU decomposition does not exist." );
      }
      printf("Zero column, adjust pivot \n" );
      m++;
    }

    else {
    */


      // Populate L column
      for ( p=n; p<=r; p++ ) {
        val = mat_get(*U,i,j)/pivot;
        printf("val: %3.3f \n", val );
        mat_set(*L,p,q,val);
      }

      // Manipulate U
      for ( i=j+1; i<=r; i++ ) {
        printf("row: %d \n", i );
        scale = -mat_get(*U,i,j)/pivot;
        printf("scale: %3.3f \n", scale );
        row = mat_getr(*U,j);
        row = mat_scale(row,scale);
        row = mat_add( row, mat_getr(*U,i) );
        mat_print(row);
        mat_setr(*U,i,row);
      }

      // New pivot position
      //p++;

      // Display the results
      printf("L: ");
      mat_print(*L);
      printf("U: ");
      mat_print(*U);

      //}

  }


  return;
}


